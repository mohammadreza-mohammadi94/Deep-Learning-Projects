# -*- coding: utf-8 -*-
"""name_generator.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1G9wQrcc3sM9nfOJuo7BulfbsRKR9t65A

# Import Libraries & Setup Enviorment
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import requests
import random

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Embedding, Dropout
from tensorflow.keras.preprocessing.sequence import pad_sequences

import warnings
warnings.filterwarnings('ignore')

import logging
logging.basicConfig(
    format="%(asctime)s-%(levelname)s-%(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
    level=logging.INFO,
    handlers=[
        logging.FileHandler("logs.log"),
        logging.StreamHandler()
    ]
)

# Setup seeds
np.random.seed(42)
tf.random.set_seed(42)

"""# Load dataset & Processing Dataset"""

def load_dataset_from_url(url):
    response = requests.get(url)
    response.raise_for_status()     # Check for errors
    names = [line.strip() for line in response.text.splitlines() if line.strip()]
    return names

# Dataset's url
lotr_url = "https://raw.githubusercontent.com/borhanMorphy/fantasy-name-generator/main/data/lotr_names.txt"
dota_url = "https://raw.githubusercontent.com/borhanMorphy/fantasy-name-generator/main/data/dota_names.txt"

# Load datasets
lotr_names = load_dataset_from_url(lotr_url)
dota_names = load_dataset_from_url(dota_url)

# Concatenate datasets
names = lotr_names + dota_names

# Remove dubplicates
names = list(set(names))
names = [name for name in names if len(name) > 1 and name.isalpha()] # To filter for valid names

print(f"Total Names: {len(names)}")

"""### Creating Vocabulary (Charachter-Level)"""

chars = sorted(list(set("".join(names))))
char_to_idx = {char: idx for idx,char in enumerate(chars)}
char_to_idx['<PAD>'] = 0

idx_to_chars = {idx: char for char, idx in char_to_idx.items()}
vocab_size = len(char_to_idx)

print(f"Vocabulary Size: {vocab_size}")

"""### Creating Sequences"""

max_len = max(len(name) for name in names) + 1
sequences = []
for name in names:
    seq = [char_to_idx[char] for char in name]
    sequences.append(seq)

# Padding sequences
X = pad_sequences(sequences, maxlen=max_len, padding='post')

"""### Creating Input/Output"""

X_train = []
y_train = []

for seq in X:
    for i in range(1, len(seq)):
        X_train.append(seq[:i])
        y_train.append(seq[i])

X_train = pad_sequences(X_train, maxlen=max_len, padding='post')
y_train = np.array(y_train)

"""# Define the Model"""

model = Sequential([
    Embedding(vocab_size, 128, input_length=max_len),
    LSTM(256, return_sequences=True),
    Dropout(0.3),
    LSTM(128),
    Dropout(0.3),
    Dense(vocab_size, activation='softmax')
])

model.compile(loss='sparse_categorical_crossentropy',
              optimizer='adam',
              metrics=['accuracy'])

model.summary()

model.fit(X_train, y_train, epochs=100, batch_size=64, verbose=1)

"""### Creating Names with Temperature Sampling"""

def sample(preds, temperature=0.7):
    preds = np.asarray(preds).astype('float64')
    preds = np.log(preds) / temperature
    exp_preds = np.exp(preds)
    preds = exp_preds / np.sum(exp_preds)
    probas = np.random.multinomial(1, preds, 1)
    return np.argmax(probas)


def generate_name(model, max_len, char_to_idx, idx_to_char,
                  seed=None, temperature=0.7, max_attempts=10):
    for _ in range(max_attempts):
        if seed is None:
            seed_idx = [random.choice(list(char_to_idx.values())[1:])]  # No padding
        else:
            seed_idx = [char_to_idx[c] for c in seed.lower() if c in char_to_idx]
            if not seed_idx:
                seed_idx = [random.choice(list(char_to_idx.values())[1:])]

        generated = seed_idx[:]
        for _ in range(max_len - len(seed_idx)):
            input_seq = pad_sequences([generated], maxlen=max_len, padding='post')
            pred = model.predict(input_seq, verbose=0)[0]
            next_char_idx = sample(pred, temperature)
            if next_char_idx == 0:  # stop padding
                break
            generated.append(next_char_idx)

        name = ''.join(idx_to_char[idx] for idx in generated if idx in idx_to_char and idx != 0)
        if len(name) > 2 and name.isalpha():  # check if name is valid
            return name
    return None

print("Randomly Generated Names: ")
for _ in range(5):
    name = generate_name(model, max_len, char_to_idx, idx_to_chars, temperature=0.7)
    if name:
        print(name.capitalize())

print("\nRandomly Generated Names (Seed 'el'):")
for _ in range(3):
    name = generate_name(model, max_len, char_to_idx, idx_to_chars, seed="el", temperature=0.7)
    if name:
        print(name.capitalize())

print("\nRandomly Generated Names (Seed 'gan'): ")
for _ in range(3):
    name = generate_name(model, max_len, char_to_idx, idx_to_chars, seed="Gan", temperature=0.7)
    if name:
        print(name.capitalize())

model.save("fantasy_name_generator_lotr_dota.h5")

